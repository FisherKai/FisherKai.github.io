[{"title":"defer和async","date":"2022-02-09T06:17:30.000Z","url":"/2022/02/09/defer%E5%92%8Casync/","categories":[["undefined",""]],"content":" ● 普通script文档解析的过程中，如果遇到script脚本，就会停止页面的解析进行下载。资源的下载是在解析过程中进行的，虽说script1脚本会很快的加载完毕，但是他前边的script2并没有加载&amp;执行，所以他只能处于一个挂起的状态，等待script2执行完毕后再执行。当这两个脚本都执行完毕后，才会继续解析页面。 ● defer文档解析时，遇到设置了defer的脚本，就会在后台进行下载，但是并不会阻止文档的渲染，当页面解析&amp;渲染完毕后。会等到所有的defer脚本加载完毕并按照顺序执行，执行完毕后会触发DOMContentLoaded事件。 ● asyncasync脚本会在加载完毕后执行。async脚本的加载不计入DOMContentLoaded事件统计，也就是说下图两种情况都是有可能发生的 ● 总结 ○ 依赖页面中dom的话可以用defer ○ 不依赖页面中dom话可以用async"},{"title":"CSS伪元素层级太高产生遮挡如何解决","date":"2021-12-15T08:51:48.000Z","url":"/2021/12/15/CSS%E4%BC%AA%E5%85%83%E7%B4%A0%E5%B1%82%E7%BA%A7%E5%A4%AA%E9%AB%98%E4%BA%A7%E7%94%9F%E9%81%AE%E6%8C%A1%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3/","categories":[["undefined",""]],"content":"​ 最近在项目开发中遇到CSS伪元素产生遮挡的问题，总结一下如何解决的。 产生场景 如图所示，背景为before伪元素生成，进度条用本身元素，通过控制宽度来改变进度。 灰色的层级（伪元素生成）会覆盖在彩色层级（本身元素）之上。 可以通过 设置index 设置transform "},{"title":"ElementUI上传多个图片列表问题","date":"2021-12-13T01:57:34.000Z","url":"/2021/12/13/ElementUI%E4%B8%8A%E4%BC%A0%E5%A4%9A%E4%B8%AA%E5%9B%BE%E7%89%87%E5%88%97%E8%A1%A8%E9%97%AE%E9%A2%98/","categories":[["undefined",""]],"content":" "},{"title":"理解浏览器缓存机制","date":"2021-10-25T02:05:52.000Z","url":"/2021/10/25/%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/","categories":[["undefined",""]],"content":"1. 缓存分析过程 强缓存 强缓存：不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且Size显示from disk cache或from memory cache。强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control。 expires 缓存过期时间，用来指定资源到期的时间，是服务器端的具体的时间点。也就是说，Expires=max-age + 请求时间，需要和Last-modified结合使用。 Cache-Control 在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存。比如当Cache-Control:max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。Cache-Control 可以在请求头或者响应头中设置，并且可以组合使用多种指令： Expires和Cache-Control两者对比区别就在于 Expires 是http1.0的产物，Cache-Control是http1.1的产物，两者同时存在的话，Cache-Control优先级高于Expires；在某些不支持HTTP1.1的环境下，Expires就会发挥用处。所以Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法。 协商缓存 协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况： 协商缓存生效，返回304和Not Modified 协商缓存失效，返回200和请求结果协商缓存可以通过设置两种 HTTP Header 实现：Last-Modified 和 ETag 。 Last-Modified和If-Modified-Since浏览器在第一次访问资源时，服务器返回资源的同时，在response header中添加 Last-Modified的header，值是这个资源在服务器上的最后修改时间，浏览器接收后缓存文件和header；Last-Modified: Fri, 22 Jul 2016 01:47:00 GMT浏览器下一次请求这个资源，浏览器检测到有 Last-Modified这个header，于是添加If-Modified-Since这个header，值就是Last-Modified中的值；服务器再次收到这个资源请求，会根据 If-Modified-Since 中的值与服务器中这个资源的最后修改时间对比，如果没有变化，返回304和空的响应体，直接从缓存读取，如果If-Modified-Since的时间小于服务器中这个资源的最后修改时间，说明文件有更新，于是返回新的资源文件和200。 Last-Modified 存在一些弊端： 如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源 因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源 ETag和If-None-MatchEtag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成。浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到request header里的If-None-Match里，服务器只需要比较客户端传来的If-None-Match跟自己服务器上该资源的ETag是否一致，就能很好地判断资源相对客户端而言是否被修改过了。如果服务器发现ETag匹配不上，那么直接以常规GET 200回包形式将新的资源（当然也包括了新的ETag）发给客户端；如果ETag是一致的，则直接返回304知会客户端直接使用本地缓存即可。 两者之间对比： 首先在精确度上，Etag要优于Last-Modified。Last-Modified的时间单位是秒。 第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。 第三在优先级上，服务器校验优先考虑Etag 如果什么缓存策略都没设置，那么浏览器会怎么处理？ 对于这种情况，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 资料参考"},{"title":"移动端软键盘弹起遮挡输入框问题的解决方案","date":"2021-09-26T15:18:01.000Z","url":"/2021/09/26/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E8%BD%AF%E9%94%AE%E7%9B%98%E5%BC%B9%E8%B5%B7%E9%81%AE%E6%8C%A1%E8%BE%93%E5%85%A5%E6%A1%86%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","categories":[["undefined",""]],"content":" title: 移动端软键盘弹起遮挡输入框问题的解决方案date: 2021-09-26 23:15:11tags: 背景原生app与H5页面混合开发时，input输入框唤起软键盘时，输入框被遮挡，分为两种情况： 客户端设置了windowSoftInputMode =”adjustResize”属性，软键盘会将webview向上抬起，偶现input框被遮挡客户端未设置windowSoftInputMode =”adjustResize”属性，软键盘在webview上方，不会将webview抬起，一直遮挡input的输入框针对情况1的解决方案当webview可以被抬起时，是可以监听到resize事件的，resize事件触发，判断input框是否在可视区内，在可视区内不做变动，否则计算距离后上移 监听resize事件 2.是否被遮挡判断 注意：这里实现的前提是客户端设置了相关属性，可以监听到resize事件针对情况2的解决方案大致计算软键盘的高度，在input的聚焦时，手动将整体加个padding，失焦时去掉padding，但是键盘抬起时，页面滑动效果不好"},{"title":"Tree shaking","date":"2021-08-23T07:02:44.000Z","url":"/2021/08/23/Tree-shaking/","categories":[["undefined",""]],"content":"当 Javascript 项目达到一定体积时，将代码分成模块会更易于管理。但是，当这样做时，我们最终可能会导入实际上未使用的代码。Tree Shaking 是一种通过消除最终文件中未使用的代码来优化体积的方法。我们来举个例子，下面是一个简单的 Javascript 文件，命名为 mathUtils.js，主要实现了基础的数学运算。 在 index.js 里，我们通过如下方式调用该文件： 假设我们正在使用像 webpack 这样的工具来打包 mathUtils.js，即使仅导入并使用了add()功能，我们也会看到文件中的所有功能都包含在最终输出中。 Tree Shaking 是如何工作的虽然 Tree Shaking 的概念早在1990年代就已经被提出。Dead code elimination in dynamic languages is a much harder problem than in static languages. The idea of a “treeshaker” originated in LISP in the 1990s.—— wikipedia但当真正作用到 Javascript 中，是在 ES6 模块规范被提出之后，因为只有模块是通过 static 方式引用时，Tree Shaking 才会起作用。在 ES6 模块规范之前，我们使用require()语法的 CommonJS 模块规范。这些模块是 dynamic 动态加载的，这意味着我们可以根据代码中的条件导入新模块。 CommonJS 模块的这种 dynamic 性质意味着无法应用 Tree Shaking，因为在实际运行代码之前无法确定需要哪些模块。在 ES6 中，引入了模块的新语法，这是 static 的。使用import语法，我们不再能够动态导入模块。如下所示的代码是不被允许的： 相反，我们必须在任何条件之外定义全局范围内的所有导入。 除其他好处外，这种新语法还可以有效地 Tree Shaking，因为可以确定导入后使用的任何代码，而无需先运行这些代码。Tree Shaking 究竟做了些什么Tree Shaking 在 Webpack 中的实现，是用来尽可能的删除没有被使用过的代码，一些被 import 了但其实没有被使用的代码。 在上面的示例中，multiply()函数从未使用过，将从最终的打包文件中删除。甚至从从未访问过的导入对象中删除特定属性。 在上面的示例中，birthday属性不会被输出到最终打包文件中，因为从未实际使用过。但是，Tree Shaking 并不能消除 所有 未使用的代码。消除和不消除的细节不在本文讨论范围之内，但应注意的是，使用 Tree Shaking 并不能完全解决未使用代码的问题。副作用一个副作用是：有一些代码，是在 import 时执行了一些行为，这些行为不一定和任何导出相关。例如 polyfill ，Polyfills 通常是在项目中全局引用，而不是在 index.js 中使用导入的方式引用。Tree Shaking 并不能自动判断哪些脚本是副作用，因此手动指定它们非常重要。如何使用Tree Shaking 通常是和打包工具配合使用，例如 Webpack，只需在配置文件中设置mode即可。 要将某些文件标记为副作用，我们需要将它们添加到package.json文件中。 删除代码的原理：webpack基于ES6提供的模块系统，对代码的依赖树进行静态分析，把import &amp; export标记为3类：• 所有import标记为/* harmony import /• 被使用过的export标记为/harmony export([type])/，其中[type]和webpack内部有关，可能是binding，immutable等；• 没有被使用的export标记为/ unused harmony export [FuncName] */，其中[FuncName]为export的方法名，之后使用Uglifyjs（或者其他类似的工具）进行代码精简，把没用的都删除。"},{"title":"Javascript垃圾回收机制","date":"2021-08-06T00:07:59.000Z","url":"/2021/08/06/Javascript%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/","categories":[["undefined",""]],"content":"首先我们要知道如果没有垃圾回收机制我们的代码会发生什么。。。答案。。。内存泄漏！所以什么是内存泄漏呢？我们知道程序运行是需要内存的，操作系统或者运行时（runtime）就必须要提供内存。对于持续运行的程序或者服务来说，必须要及时释放不再用的内存。否则，内存占用越来越高。就会导致系统性能（卡顿等），程序崩溃等。 而不在使用的内存没有得到及时的释放，就叫做内存泄漏。有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为”垃圾回收机制”（garbage collector）。垃圾回收机制垃圾回收机制会在创建变量时自动分配内存，在不使用的时候会自动周期性的释放内存，释放的过程就叫 “垃圾回收”。这个机制有好的一面，当然也也有不好的一面。一方面自动分配内存减轻了开发者的负担，开发者不用过多的去关注内存使用，但是另一方面，正是因为因为是自动回收，所以如果不清楚回收的机制，会很容易造成混乱，而混乱就很容易造成”内存泄漏”.由于是自动回收，所以就存在一个 “内存是否需要被回收的” 的问题，但是这个问题的判定在程序中意味着无法通过某个算法去准确完整的解决，后面探讨的回收机制只能有限的去解决一般的问题。回收算法• 标记清除垃圾回收器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记（闭包）。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾回收器完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。目前主流浏览器都是使用标记清除式的垃圾回收策略，只不过收集的间隔有所不同缺点：1、回收后会形成内存碎片，影响后面申请大的连续内存空间• 引用计数引用计数策略相对而言不常用，因为弊端较多。其思路是对每个值记录它被引用的次数，通过最后对次数的判断(引用数为0)来决定是否保留，具体的规则有1、声明一个变量，赋予它一个引用值时，计数+1；2、同一个值被赋予另外一个变量时，引用+1；3、保存对该值引用的变量被其他值覆盖，引用-1；4、引用为0，回收内存；缺点：最主要的就是循环引用的问题 Nodejs V8回收机制首先先来了解V8的内存结构 • 新生代（New Space/Young Generation）： 大多数新生对象被分配到这，分为两块空间，整体占据小块空间，垃圾回收的频率较高，采用的回收算法为 Scavenge 算法• 老生代（Old Space/Old Generation）：大多数在新生区存活一段时间后的对象会转移至此，采用的回收算法为标记清除 &amp; 整理（Mark-Sweep &amp; Mark-Compact，Major GC）算法，内部再细分为两个空间• 指针空间（Old pointer space）: 存储的对象含有指向其他对象的指针• 数据空间（Old data space）：存储的对象仅包含数据，无指向其他对象的指针• 大对象空间（Large Object Space）：存放超过其他空间（Space）限制的大对象，垃圾回收器从不移动此空间中的对象• 代码空间（Code Space）: 代码对象，用于存放代码段，是唯一拥有执行权限的内存空间，需要注意的是如果代码对象太大而被移入大对象空间，这个代码对象在大对象空间内也是拥有执行权限的，但不能因此说大对象空间也有执行权限• Cell空间、属性空间、Map空间 （Cell ,Property,Map Space）： 这些区域存放Cell、属性Cell和Map，每个空间因为都是存放相同大小的元素，因此内存结构很简单。Scavenge 算法Scavenge 算法是新生代空间中的主要算法，该算法由 C.J. Cheney 在 1970 年在论文 提出。Scavenge 主要采用了 算法，Cheney算法新生代空间的堆内存分为2块同样大小的空间，称为 Semi space，处于使用状态的成为 From空间 ，闲置的称为 To 空间。垃圾回收过程如下：• 检查From空间，如果From空间被分配满了，则执行Scavenge算法进行垃圾回收• 如果未分配满，则检查From空间的是否有存活对象，如果无存活对象，则直接释放未存活对象的空间• 如果存活，将检查对象是否符合晋升条件，如果符合晋升条件，则移入老生代空间，否则将对象复制进To空间• 完成复制后将From和To空间角色互换，然后再从第一步开始执行晋升条件 经历过一次Scavenge 算法筛选； To空间内存使用超过25%； 标记清除 &amp; 整理（Mark-Sweep &amp; Mark-Compact，Major GC）算法之前说过，标记清除策略会产生内存碎片，从而影响内存的使用，这里 标记整理算法（Mark-Compact）的出现就能很好的解决这个问题。标记整理算法是在 标记清除（Mark-Sweep ）的基础上演变而来的，整理算法会将活跃的对象往边界移动，完成移动后，再清除不活跃的对象。 由于需要移动移动对象，所以在处理速度上，会慢于Mark-Sweep。全停顿（Stop The World ）为了避免应用逻辑与垃圾回收器看到的逻辑不一样，垃圾回收器在执行回收时会停止应用逻辑，执行完回收任务后，再继续执行应用逻辑。这种行为就是 全停顿，停顿的时间取决与不同引擎执行一次垃圾回收的时间。这种停顿对新生代空间的影响较小，但对老生代空间可能会造成停顿的现象。增量标记（Incremental Marking）为了解决全停顿的现象，2011年V8推出了增量标记。V8将标记过程分为一个个的子标记过程，同时让垃圾回收标记和JS应用逻辑交替进行，直至标记完成。 那我们日常中如何监听内存使用情况 1、对于chrome浏览器（84.0.4147.105），F12打开开发者工具；2、在More Tools中找到Performance monitor；常见的内存泄漏场景 意外声明全局变量 未声明的对象会被绑定在全局对象上，就算不被使用了，也不会被回收，所以写代码的时候，一定要记得声明变量。 定时器 定时器的回调通过闭包引用了外部变量，如果定时器不清除，name会一直占用着内存，所以用定时器的时候最好明白自己需要哪些变量，检查定时器内部的变量，另外如果不用定时器了，记得及时清除定时器。 闭包 由于闭包会常驻内存，在这个例子中，如果out一直存在，name就一直不会被清理，如果name值很大的时候，就会造成比较严重的内存泄漏。所以一定要慎重使用闭包。 事件监听 在页面初始化时绑定了事件监听，但是在页面离开的时候未清除事监听，就会导致内存泄漏。 缓存爆炸通过 Object/Map 的内存缓存可以极大地提升程序性能，但是很有可能未控制好缓存的大小和过期时间，导致失效的数据仍缓存在内存中，导致内存泄漏： 上面这段代码中，会不断的设置缓存，但是没有释放缓存的代码，导致内存最终被撑爆。参考资料：阮一峰的《JavaScript 内存泄漏教程》一起来看Javascript的垃圾回收机制跟我学习javascript的垃圾回收机制与内存管理javascript垃圾回收机制 - 标记清除法/引用计数/V8机制有意思的 Node.js 内存泄漏问题 "},{"title":"移动端touch事件总结","date":"2021-08-05T15:29:01.000Z","url":"/2021/08/05/%E7%A7%BB%E5%8A%A8%E7%AB%AFtouch%E4%BA%8B%E4%BB%B6%E6%80%BB%E7%BB%93/","categories":[["undefined",""]],"content":"移动端touch事件 touch事件也有event，event的type为事件的类型（start，move，end，cancel）。event.target为当前元素。但是要注意的是move与end的target目标元素为触发start的时候的元素 touch事件的touches保存了当前触点的个数及其位置信息等（值为数组） touch事件的穿透问题 场景：当有蒙层的时候，蒙层为渲染节点的最外层的兄弟节点，触发touchstart事件后，由于移动端的300ms的延迟，会导致300ms之后触发button的onclick事件、ab标签的跳转的、input的focus事件等 解决办法 封装tap事件，阻止掉事件的默认行为 e.preventDefault() 引入fastChlick "},{"title":"跨域总结","date":"2021-08-05T15:24:42.000Z","url":"/2021/08/05/%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/","categories":[["undefined",""]],"content":"同源策略协议 域名 端口 同域 不支持跨域cookie LocalStorageDOM元素的同源策略–iframeajax 也不支持跨域 实现跨域 jsonpjsonp是使用方法回调的原理.在网页里, 你如果引入其他网页的js, 那这个页面的js是可以调用你网页的代码的直接请求js 和 请求的动态页面(jsp, php, aspx)里输出的javascript代码 效果一样.jsonp请求不是Ajax请求，是一般的get请求，由script标签模拟。基本步骤： 浏览器端动态生成script标签来请求后台接口（callback=jp01），并且定义好返回的处理响应数据的回调函数 服务端接受数据后返回一个立即执行函数，并把数据放在立即执行函数里 jp01&amp;&amp;(js01(){“xxxx”})() 浏览器回调函数调用缺点：只能支持get请求；不安全 xss攻击 cors用在服务端 postMessage document.domain 一般用于父域与子域进行通信 window.name location.hash http-proxy nginx websocket "}]